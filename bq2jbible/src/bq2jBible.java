/*
 * bq2jBible: конвертер модулей "Цитата из Библии" в модули jБиблии
 * Работа начата 9 Марта 2007 г., 1я версия опубликована 26 Марта 2007г
 */

import java.io.*;
import java.awt.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.*;
import javax.swing.filechooser.FileFilter;
import java.util.*;
import java.util.zip.*;
import java.util.jar.*;

/**
 * конвертор модулей "Цитата из Библии"
 * @author Сергей Ирюпин webmaster@biblelamp.ru, +7 918 557 2926
 */
public class bq2jBible extends javax.swing.JFrame implements java.awt.event.ActionListener {

    /** Название программы
     */
    public static final String APP_TITLE = "Конвертер BQ->jBible";
    
    /** Версия программы
     */
    public static final String APP_VERSION = "1.10.2";
    
    /** Дата релиза
     */
    public static final String APP_DATE = "23.04.2011";
    
    /** Текущая версия jBible
     */
    public static final String JBIBLE_VERSION = "1.3.15";
    
    /** Назначение программы
     */
    public static final String APP_DESCRIPTION =
        "конвертирование Библейских модулей"+
        "\nформата «Цитата из Библии» в модули jBible"+
        "\n(Библия в мобильном телефоне, версия "+JBIBLE_VERSION+")";
    
    /** Автор программы
     */
    public static final String APP_DEVELOPERS = "Сергей Ирюпин (http://rostovchurch.ru)";
    
    /** Контактная информация об авторе программы
     */
    public static final String APP_DEVELOPERS_CONTACT = "webmaster@biblelamp.ru";
    
    /** JAR файл мобильной части jBible
     */
    public static final String JBIBLE_JAR = "bq2jbible.jar";
    
    /** Папка с мобильной частью jBible
     */
    public static final String MOBILE_DIR = "mobile/";
    
    /** Файл индекса модуля Библии
     */
    public static final String BIBLE_INDEX = "bible/index";
    
    /** Иконка приложения
     */
    public static final String JBIBLE_ICON = "mobile/imgs/jBible.png";
    
    /** Файл с настройками модуля Цитаты из Библии
     */
    public static final String BQ_INI = "BibleQT.ini";
    
    /** Каталог Цитаты по умолчанию
     */
    public static final String BQ_DIR = "C:/Program files/BibleQuote/";
    
    /** Массив используемых локалей
     */
    public static final String Locales[] = {"ru_RU","ua_UA","by_BY","en_UZ"};

    /** Флажки для выбора книг
     */
    private JCheckBox[] checkBooks;
    
    /** Признак Библейского модуля
     */
    private boolean isBible;
    
    /** Признак наличия номеров Стронга
     */
    private boolean isStrongNumbers;
    
    /** Признак начала главы
     */
    private String chapterSign;

    /** Признак начала стиха
     */
    private String verseSign;

    /** Имя файла книги
     */
    private String pathName;

    /** Количество глав в книге
     */
    private String chapterQty;

    /** Путь к каталогу c модулем Цитаты из Библии
     */
    private String pathBQModule;

    /** Диалог открытия файла
     */
    private JFileChooser chooserOpen = new JFileChooser();

     /** Фильтр, отображающий файлы bibleqt.ini
     */
    private FileFilter filterBQ = new FileFilter() {

        public boolean accept(File f) {
            if(f.isDirectory()) return true;
            String name = f.getName().toLowerCase();
            return name.equalsIgnoreCase(BQ_INI);
        }

        public String getDescription() {
            return "Файлы "+BQ_INI;
        }
    };

    /** Создаем новую форму bq2jBible
     */
    public bq2jBible() {
        initComponents();
        setTitle(APP_TITLE+" версия "+APP_VERSION+" от "+APP_DATE); // заголовок формы
        // проверяем наличие файла jbible.jar в папке
        File f = new File(JBIBLE_JAR);
        if (!f.exists()) {
            btnOpen.setEnabled(false);
            txtStatus.setText(" Файл "+JBIBLE_JAR+" не обнаружен. Продолжение работы невозможно.");
        } else txtStatus.setText(" Готов.");
        chooserOpen.setFileSelectionMode(JFileChooser.FILES_ONLY);
        lstLocale.setSelectedIndex(0);
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        groupChoice = new javax.swing.ButtonGroup();
        btnExit = new javax.swing.JButton();
        btnOpen = new javax.swing.JButton();
        btnSave = new javax.swing.JButton();
        btnAbout = new javax.swing.JButton();
        panelModule = new javax.swing.JPanel();
        txtPath = new javax.swing.JTextField();
        labelPath = new javax.swing.JLabel();
        labelModuleName = new javax.swing.JLabel();
        txtModuleName = new javax.swing.JTextField();
        scrollBooks = new javax.swing.JScrollPane();
        panelBooks = new javax.swing.JPanel();
        panelMidlet = new javax.swing.JPanel();
        labelMidletName = new javax.swing.JLabel();
        txtMidletName = new javax.swing.JTextField();
        labelChoice = new javax.swing.JLabel();
        radioChoice1 = new javax.swing.JRadioButton();
        radioChoice4 = new javax.swing.JRadioButton();
        radioChoice3 = new javax.swing.JRadioButton();
        radioChoice2 = new javax.swing.JRadioButton();
        txtStatus = new javax.swing.JTextField();
        jScrollPane1 = new javax.swing.JScrollPane();
        lstLocale = new javax.swing.JList();
        labelLocale = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("\u041a\u043e\u043d\u0432\u0435\u0440\u0442\u043e\u0440 \u043c\u043e\u0434\u0443\u043b\u0435\u0439 BQ \u0434\u043b\u044f j\u0411\u0438\u0431\u043b\u0438\u0438");
        setBounds(new java.awt.Rectangle(150, 120, 0, 0));
        setResizable(false);
        btnExit.setText("\u0412\u044b\u0445\u043e\u0434");
        btnExit.addActionListener(this);

        btnOpen.setText("\u041e\u0442\u043a\u0440\u044b\u0442\u044c");
        btnOpen.addActionListener(this);

        btnSave.setText("\u0417\u0430\u043f\u0438\u0441\u0430\u0442\u044c");
        btnSave.setEnabled(false);
        btnSave.addActionListener(this);

        btnAbout.setText("\u041e \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0435");
        btnAbout.setMargin(new java.awt.Insets(2, 5, 2, 5));
        btnAbout.addActionListener(this);

        panelModule.setBorder(javax.swing.BorderFactory.createTitledBorder("\u041c\u043e\u0434\u0443\u043b\u044c \u0426\u0438\u0442\u0430\u0442\u044b \u0438\u0437 \u0411\u0438\u0431\u043b\u0438\u0438"));
        txtPath.setEditable(false);

        labelPath.setText("\u041f\u0443\u0442\u044c:");

        labelModuleName.setText("\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435:");

        txtModuleName.setEditable(false);

        org.jdesktop.layout.GroupLayout panelModuleLayout = new org.jdesktop.layout.GroupLayout(panelModule);
        panelModule.setLayout(panelModuleLayout);
        panelModuleLayout.setHorizontalGroup(
            panelModuleLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(panelModuleLayout.createSequentialGroup()
                .addContainerGap()
                .add(panelModuleLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(labelPath)
                    .add(labelModuleName))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(panelModuleLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, txtPath, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 485, Short.MAX_VALUE)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, txtModuleName, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 485, Short.MAX_VALUE))
                .addContainerGap())
        );
        panelModuleLayout.setVerticalGroup(
            panelModuleLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(panelModuleLayout.createSequentialGroup()
                .add(panelModuleLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(labelPath)
                    .add(txtPath, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(panelModuleLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(labelModuleName)
                    .add(txtModuleName, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        org.jdesktop.layout.GroupLayout panelBooksLayout = new org.jdesktop.layout.GroupLayout(panelBooks);
        panelBooks.setLayout(panelBooksLayout);
        panelBooksLayout.setHorizontalGroup(
            panelBooksLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 428, Short.MAX_VALUE)
        );
        panelBooksLayout.setVerticalGroup(
            panelBooksLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 338, Short.MAX_VALUE)
        );
        scrollBooks.setViewportView(panelBooks);

        panelMidlet.setBorder(javax.swing.BorderFactory.createTitledBorder("\u041c\u043e\u0434\u0443\u043b\u044c j\u0411\u0438\u0431\u043b\u0438\u0438"));
        labelMidletName.setText("\u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435:");

        labelChoice.setText("\u0412\u044b\u0431\u0440\u0430\u0442\u044c:");

        groupChoice.add(radioChoice1);
        radioChoice1.setSelected(true);
        radioChoice1.setText("\u0432\u0441\u0435 \u043a\u043d\u0438\u0433\u0438");
        radioChoice1.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        radioChoice1.setEnabled(false);
        radioChoice1.setMargin(new java.awt.Insets(0, 0, 0, 0));
        radioChoice1.addActionListener(this);

        groupChoice.add(radioChoice4);
        radioChoice4.setText("\u043a\u0430\u043d\u043e\u043d\u0438\u0447\u0435\u0441\u043a\u0438\u0435");
        radioChoice4.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        radioChoice4.setEnabled(false);
        radioChoice4.setMargin(new java.awt.Insets(0, 0, 0, 0));
        radioChoice4.addActionListener(this);

        groupChoice.add(radioChoice3);
        radioChoice3.setText("\u041d\u043e\u0432\u044b\u0439 \u0417\u0430\u0432\u0435\u0442");
        radioChoice3.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        radioChoice3.setEnabled(false);
        radioChoice3.setMargin(new java.awt.Insets(0, 0, 0, 0));
        radioChoice3.addActionListener(this);

        groupChoice.add(radioChoice2);
        radioChoice2.setText("\u0438\u043d\u0432\u0435\u0440\u0441\u0438\u044f");
        radioChoice2.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        radioChoice2.setEnabled(false);
        radioChoice2.setMargin(new java.awt.Insets(0, 0, 0, 0));
        radioChoice2.addActionListener(this);

        org.jdesktop.layout.GroupLayout panelMidletLayout = new org.jdesktop.layout.GroupLayout(panelMidlet);
        panelMidlet.setLayout(panelMidletLayout);
        panelMidletLayout.setHorizontalGroup(
            panelMidletLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(panelMidletLayout.createSequentialGroup()
                .addContainerGap()
                .add(panelMidletLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(labelMidletName)
                    .add(labelChoice))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(panelMidletLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(txtMidletName, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 355, Short.MAX_VALUE)
                    .add(panelMidletLayout.createSequentialGroup()
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(radioChoice1)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(radioChoice2)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(radioChoice3)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(radioChoice4)))
                .addContainerGap())
        );
        panelMidletLayout.setVerticalGroup(
            panelMidletLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(panelMidletLayout.createSequentialGroup()
                .add(panelMidletLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(labelMidletName)
                    .add(txtMidletName, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .add(panelMidletLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(labelChoice)
                    .add(radioChoice1)
                    .add(radioChoice3)
                    .add(radioChoice4)
                    .add(radioChoice2))
                .addContainerGap())
        );

        txtStatus.setEditable(false);
        txtStatus.setFont(new java.awt.Font("Tahoma", 1, 11));

        lstLocale.setModel(new javax.swing.AbstractListModel() {
            String[] strings = { "\u0420\u0443\u0441\u0441\u043a\u0438\u0439", "\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430", "\u0411\u0435\u043b\u0430\u0440\u0443\u0441\u043a\u0438\u0439", "O'zbekcha" };
            public int getSize() { return strings.length; }
            public Object getElementAt(int i) { return strings[i]; }
        });
        lstLocale.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        jScrollPane1.setViewportView(lstLocale);

        labelLocale.setText("\u042f\u0437\u044b\u043a \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430:");

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, panelModule, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .add(layout.createSequentialGroup()
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                            .add(scrollBooks, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 443, Short.MAX_VALUE)
                            .add(panelMidlet, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 125, Short.MAX_VALUE)
                            .add(btnSave, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 125, Short.MAX_VALUE)
                            .add(btnOpen, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 125, Short.MAX_VALUE)
                            .add(btnAbout, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 125, Short.MAX_VALUE)
                            .add(btnExit, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 125, Short.MAX_VALUE)
                            .add(org.jdesktop.layout.GroupLayout.TRAILING, labelLocale, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 125, Short.MAX_VALUE))))
                .addContainerGap())
            .add(txtStatus, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 594, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .add(panelModule, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(layout.createSequentialGroup()
                        .add(14, 14, 14)
                        .add(btnOpen)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(btnSave)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(labelLocale)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 121, Short.MAX_VALUE)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(btnAbout)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(btnExit)
                        .add(6, 6, 6))
                    .add(layout.createSequentialGroup()
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(panelMidlet, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 69, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(scrollBooks, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 190, Short.MAX_VALUE)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)))
                .add(txtStatus, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
        );
        pack();
    }

    // Code for dispatching events from components to event handlers.

    public void actionPerformed(java.awt.event.ActionEvent evt) {
        if (evt.getSource() == btnExit) {
            bq2jBible.this.btnExitActionPerformed(evt);
        }
        else if (evt.getSource() == btnOpen) {
            bq2jBible.this.btnOpenActionPerformed(evt);
        }
        else if (evt.getSource() == btnSave) {
            bq2jBible.this.btnSaveActionPerformed(evt);
        }
        else if (evt.getSource() == btnAbout) {
            bq2jBible.this.btnAboutActionPerformed(evt);
        }
        else if (evt.getSource() == radioChoice1) {
            bq2jBible.this.radioChoice1ActionPerformed(evt);
        }
        else if (evt.getSource() == radioChoice4) {
            bq2jBible.this.radioChoice4ActionPerformed(evt);
        }
        else if (evt.getSource() == radioChoice3) {
            bq2jBible.this.radioChoice3ActionPerformed(evt);
        }
        else if (evt.getSource() == radioChoice2) {
            bq2jBible.this.radioChoice2ActionPerformed(evt);
        }
    }// </editor-fold>//GEN-END:initComponents

     /** Информация о программе
     */
    private void btnAboutActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAboutActionPerformed
        //ImageIcon icon = new ImageIcon(getClass().getResourceAsStream(JBIBLE_ICON));
        //ImageIcon icon = ImageIcon(ImageIO.read(getClass().getResourceAsStream(JBIBLE_ICON), "PNG"));
        JOptionPane.showMessageDialog(this,
            "Программа: "+APP_TITLE+
            "\nверсия: "+APP_VERSION+" ("+APP_DATE+")"+
            "\n\nНазначение: "+APP_DESCRIPTION+
            "\n\nАвтор: "+APP_DEVELOPERS+
            "\nКонтакт: "+APP_DEVELOPERS_CONTACT,
            " О программе",
            JOptionPane.INFORMATION_MESSAGE);
            //icon);
            //this.getClass().getResourceAsStream(JBIBLE_ICON));
    }//GEN-LAST:event_btnAboutActionPerformed

    /** Блок обработки нажатий на радио-кнопки
     */
    // все книги
    private void radioChoice1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_radioChoice1ActionPerformed
        for(int i=0;i<checkBooks.length;i++)
            checkBooks[i].setSelected(true);
    }//GEN-LAST:event_radioChoice1ActionPerformed
    // канонические книги (первые 66)
    private void radioChoice4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_radioChoice4ActionPerformed
        for(int i=0;i<checkBooks.length;i++)
            if (i<66) checkBooks[i].setSelected(true);
            else checkBooks[i].setSelected(false);
    }//GEN-LAST:event_radioChoice4ActionPerformed
    // книги Нового Завета
    private void radioChoice3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_radioChoice3ActionPerformed
        if (checkBooks.length<27)
            for(int i=0;i<checkBooks.length;i++)
                checkBooks[i].setSelected(true);
        else
            for(int i=0;i<checkBooks.length;i++)
                if ((i>38)&&(i<66)) checkBooks[i].setSelected(true);
                else checkBooks[i].setSelected(false);
        txtMidletName.setText("Новый Завет"); // меняем название мидлета
    }//GEN-LAST:event_radioChoice3ActionPerformed
    // инверсия
    private void radioChoice2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_radioChoice2ActionPerformed
        for(int i=0;i<checkBooks.length;i++)
            checkBooks[i].setSelected(!checkBooks[i].isSelected());
        if (checkBooks.length>26)
            if (txtMidletName.getText().startsWith("Новый Завет")) 
                txtMidletName.setText("Ветхий Завет");
            else 
                if (txtMidletName.getText().startsWith("Ветхий Завет")) 
                    txtMidletName.setText("Новый Завет");
    }//GEN-LAST:event_radioChoice2ActionPerformed

     /** При нажатии на кнопку "Открыть"
     */
    private void btnOpenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnOpenActionPerformed
        try {
            File d = new File(BQ_DIR);
            if(d.isDirectory()) chooserOpen.setCurrentDirectory(d);
            chooserOpen.setFileFilter(filterBQ);
            chooserOpen.setDialogTitle("Открыть файл "+BQ_INI);
            //chooserOpen.setCurrentDirectory("C:/Program files/BibleQuote/");
            int result = chooserOpen.showOpenDialog(this);
            if(result == JFileChooser.APPROVE_OPTION) {
                File f = chooserOpen.getSelectedFile();
                if(f.exists() && f.canRead()) {
                   // "C:/Program files/BibleQuote/RstStrong/BibleQT.ini"
                   IniFileReader(f.getAbsolutePath());
                } else {
                    JOptionPane.showMessageDialog(this,"Невозможно открыть файл: "+f.getAbsolutePath(),"Ошибка",JOptionPane.ERROR_MESSAGE);
                }
            }
        } catch(Exception e) {
            System.out.println(e.getMessage());
        }
    }//GEN-LAST:event_btnOpenActionPerformed
    
    /** Чтение и разбор ini файла
     */
    private void IniFileReader(String ini) throws IOException {
        
        // инициализируем признак модуля
        isBible = false;
        
        // инициализируем счетчик книг-флажков
        int i = -1;

        // показываем файл и запоминаем путь
        txtPath.setText(ini);
        pathBQModule = ini.substring(0, ini.length()-11);

        // очищаем и готовим панель
        panelBooks.removeAll();
        panelBooks.setLayout(new GridLayout(0,2));
        
        // читаем ini файл
        InputStreamReader f = new InputStreamReader(new FileInputStream(ini),"CP1251");
        BufferedReader reader = new BufferedReader(f);
        String s = null;
        while((s=reader.readLine()) != null) {
            // нашли название модуля, отображаем
            if (s.startsWith("BibleName")) {
                txtModuleName.setText(s.substring(12));
            }
            // нашли признак модуля (Библия/не Библия)
            if (s.startsWith("Bible")) {
                isBible = (s.charAt(8) == 'Y');
            }
            // нашли признак наличия номеров Стронга
            if (s.startsWith("StrongNumbers")) {
                isStrongNumbers = (s.charAt(16) == 'Y');
            }
            // нашли признак начала главы
            if (s.startsWith("ChapterSign")) {
                chapterSign = s.substring(14);
            }
            // нашли признак начала стиха
            if (s.startsWith("VerseSign")) {
                verseSign = s.substring(12);
            }
            // нашли количество книг, создаем массив флажков
            if (s.startsWith("BookQty")) {
                checkBooks = new JCheckBox[Integer.parseInt(s.substring(10))];
            }
            // нашли название книги
            if(s.startsWith("FullName")) {
                // наращиваем счетчик
                i++;
                // выводим на панель флажок с названием книги
                checkBooks[i] = new JCheckBox(ShortBookName(s.substring(11)),true);
                panelBooks.add(checkBooks[i]);
            }
        }
        validate();
        reader.close();
        // включаем кнопку записи
        if (isBible) btnSave.setEnabled(true);
        // включаем поле названия мидлета
        txtMidletName.setEnabled(true);
        // включаем чекбоксы отбора
        radioChoice1.setEnabled(true);
        radioChoice2.setEnabled(true);
        radioChoice3.setEnabled((i>26));
        radioChoice4.setEnabled((i>65));
        // выставляем предварительное название мидлета
        if (i == 26) {
            if (txtModuleName.getText().startsWith("Радостная")) 
                txtMidletName.setText("Радостная Весть");
            else txtMidletName.setText("Новый Завет");
        } else txtMidletName.setText("Библия");
        // выводим сообщение
        txtStatus.setText(" Открытый модуль содержит "+(i+1)+" книг.");
    }
    
    /** Сокрашение названия книги
     */
    private String ShortBookName(String bookName) {
        if (bookName.startsWith("К ")) return bookName.substring(2); // "К Евреям"->"Евреям"
        if (bookName.startsWith("От ")) return bookName.substring(3); // "От Марка"->"Марка"
        if (bookName.indexOf('-')>0) return // убираем -я (Царств), 1-е (Иоанна,Петра)
            bookName.substring(0,bookName.indexOf('-'))+bookName.substring(bookName.indexOf('-')+2);
        return bookName;
    }

    /** При нажатии на кнопку "Записать"
     */
    private void btnSaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSaveActionPerformed
        try {
            SaveMidletFile(txtMidletName.getText()+".jar"); // имя файла = имя мидлета
        } catch(Exception e) {
            System.out.println(e.getMessage());
        }
    }//GEN-LAST:event_btnSaveActionPerformed
    
    /** Создание мидлета jBible с набором выбранных книг
     */
    private void SaveMidletFile(String saveFile) throws IOException {
        
        // создаем выходные потоки
        FileOutputStream out = new FileOutputStream(saveFile);
        ZipOutputStream zipOut = new ZipOutputStream(out);        
        DataOutputStream dos = new DataOutputStream(zipOut);

        // создаем ссылку на файл (чтобы знать размер)
        File fileJAR = new File(saveFile);
        
        // переносим неизменяемую мобильную часть
        // создаем переменные для переноса
        byte[] buf = new byte[1024];
        final String MIDletName = "MIDlet-Name: ";
        final String MIDlet1 = "MIDlet-1: ";
        
        // переносим выбранный файл локали интерфейса
        ZipFile jarFile = new ZipFile(JBIBLE_JAR);
        ZipEntry localesFile = new ZipEntry("locale/locales");
        zipOut.putNextEntry(localesFile);
        dos.writeUTF(Locales[lstLocale.getSelectedIndex()]+"\t"+lstLocale.getSelectedValue()+"\n"); // файл /locale/locales ссылка на локаль
        dos.flush();
        zipOut.closeEntry();
        JarFile distFile = new JarFile(JBIBLE_JAR);
        ZipEntry newEntry = new ZipEntry("locale/"+Locales[lstLocale.getSelectedIndex()]);
        zipOut.putNextEntry(newEntry);
        JarEntry currEntry = distFile.getJarEntry(MOBILE_DIR+"locale/"+Locales[lstLocale.getSelectedIndex()]);
        if(currEntry == null) throw new IOException("Отсутствует локаль "+Locales[lstLocale.getSelectedIndex()]+" в "+JBIBLE_JAR+" jar файле.");
        InputStream is = distFile.getInputStream(currEntry);
        while(is.available()>0) {
            int len = is.read(buf);
            zipOut.write(buf,0,len); // файл /locale/выбранная_локаль
        }
        is.close();
        zipOut.closeEntry();
        
        // классы мобильной части
        Enumeration en = jarFile.entries();
        while(en.hasMoreElements()) {
            ZipEntry entry = (ZipEntry)en.nextElement();
            if(entry.getName().startsWith(MOBILE_DIR) // мобильную часть берем из папки /mobile
               && (entry.getName().length() > 7) // не переносим элемент "mobile/"
               && !entry.getName().startsWith(MOBILE_DIR+"bible") // не переносим папку /bible
               && !entry.getName().startsWith(MOBILE_DIR+"locale")) // локаль уже перенесли
            {
                InputStream inp = jarFile.getInputStream(entry);
                if(entry.getName().equals(MOBILE_DIR+"META-INF/MANIFEST.MF")) {
                    entry = new ZipEntry(entry.getName().substring(7)); // отрезаем "mobile/"
                    zipOut.putNextEntry(entry);
                    BufferedReader reader = new BufferedReader(new InputStreamReader(inp,"UTF-8"));
                    OutputStreamWriter writer = new OutputStreamWriter(zipOut,"UTF-8");
                    String line = reader.readLine();
                    while(line!=null) {
                        if(line.startsWith(MIDletName)) line = MIDletName+txtMidletName.getText().trim();
                        if(line.startsWith(MIDlet1)) line = MIDlet1+txtMidletName.getText().trim()+line.substring(line.indexOf(','));
                        writer.write(line+"\n");
                        line = reader.readLine();
                    }
                    writer.flush();
                } else {
                    entry = new ZipEntry(entry.getName().substring(7)); // отрезаем "mobile/"
                    zipOut.putNextEntry(entry);
                    while(inp.available()>0) {
                        int len = inp.read(buf);
                        zipOut.write(buf,0,len);
                    }
                }
                inp.close();
            }
        }
        zipOut.closeEntry();

        // определяем количество книг, инициализируя массив verseCount;
        int verseCount[][];
        int n = 0;
        for(int i=0;i<checkBooks.length;i++) if (checkBooks[i].isSelected()) n++;
        verseCount = new int[n][];
        
        // собираем данные, готовя их для записи
        // создаем массив для текстов
        // читаем ini файл
        FileReader f = new FileReader(txtPath.getText());
        BufferedReader readini = new BufferedReader(f);
        ArrayList bookNames = new ArrayList(); // список названий книг
        ArrayList bibleBook = new ArrayList(); // массив глав книги
        ArrayList сhapterVerses = new ArrayList(); // массив стихов в главе
        String contentTXT = null;
        String s = null;
        int i = -1;
        n = 0;
        while((s=readini.readLine()) != null) {
            // нашли путь к файлу
            if(s.startsWith("PathName")) {
                i++;
                if (checkBooks[i].isSelected()) { // читаем файл книги
                    n++;
                    contentTXT = "";
                    bibleBook.clear();
                    bibleBook = ReadBibleBook(pathBQModule+s.substring(11)); // читаем книгу
                    verseCount[n-1] = new int[bibleBook.size()]; // число глав в книге
                    // пишем книгу в jar
                    for(int chapter=0;chapter<bibleBook.size();chapter++) {
                        ZipEntry chaptersBook = new ZipEntry("bible/"+n+"/"+(chapter+1)+".txt");
                        zipOut.putNextEntry(chaptersBook);
                        сhapterVerses.clear();
                        сhapterVerses = ReadBibleBookChapterVerses((String)bibleBook.get(chapter)); // читаем стихи
                        verseCount[n-1][chapter] = (int)сhapterVerses.size(); // количество стихов в главе
                        for(int verse=0;verse<сhapterVerses.size();verse++)
                            dos.writeUTF((String)сhapterVerses.get(verse)+"\n");
                        zipOut.closeEntry();
                    }
                }
            }
            // нашли количество глав
            if(s.startsWith("ChapterQty")) {
                chapterQty = s.substring(13);
                if (checkBooks[i].isSelected()) // пополняем список книг
                    bookNames.add(checkBooks[i].getText());
            }
        }
        readini.close();

        // пишем файл bible/index
        ZipEntry indexFile = new ZipEntry(BIBLE_INDEX);
        zipOut.putNextEntry(indexFile);
        dos.writeByte(bookNames.size()); // количество книг
        //dos.writeInt(bookNames.size()); // количество книг
        for(i=0;i<bookNames.size();i++) {
            dos.writeUTF((String)bookNames.get(i)); // название книги
            dos.writeByte(verseCount[i].length); // количество глав
            //dos.writeInt(verseCount[i].length); // количество глав
            for (int j=0;j<verseCount[i].length;j++)
                 dos.writeByte(verseCount[i][j]); // количество стихов в главе
                 //dos.writeInt(verseCount[i][j]); // количество стихов в главе
        }
        dos.flush();
        zipOut.closeEntry();

        // закрываем поток вывода
        zipOut.close();

        // выводим сообщение
        txtStatus.setText(" Записан модуль из "+n+" книг ("+(fileJAR.length()/1024)+" Кб).");
    }

    /** Чтение файла-книги Библии
     *  возвращает массив строк, каждая глава в отдельной строке
     */
    private ArrayList ReadBibleBook(String bookFile) throws IOException {
        ArrayList result = new ArrayList(); // объявляем переменную результата
        System.out.println(bookFile); // отображаем имя файла (отладка)
        FileReader fr = new FileReader(bookFile); // чтение CP1251
        //InputStreamReader fr = new InputStreamReader(new FileInputStream(bookFile),"UTF-8"); // чтение UTF-8
        BufferedReader readbook = new BufferedReader(fr);
        String s;
        String verse = "";
        String chapter = "";
        while((s=readbook.readLine()) != null) {
            //System.out.println(s);
            // нашли начало новой главы
            if (s.startsWith(chapterSign)) {
                if (chapter != "") {
                    if (verse != "") {
                        chapter = chapter + verse.trim() + "\n"; // дописываем последний стих
                        verse = ""; // очищаем стих
                    }
                    result.add(chapter); // сохраняем собранную главу
                }
                chapter = "";
            }
            // нашли начало стиха
            else if (s.startsWith(verseSign)) {
                if (verse != "") chapter = chapter + verse.trim() + "\n"; // дописываем последний стих
                verse = DeleteVNumber(DeleteStrongsN(StripTags(s)));
            } else if ((StripTags(s) != "") && (verse != "")){
                verse = verse.trim() + " " + DeleteStrongsN(StripTags(s)); // дополняем стих
            }
        }
        readbook.close();
        if (verse != "") chapter = chapter + verse.trim() + "\n"; // дописываем последний стих
        result.add(chapter); // сохраняем последнюю главу
        return result;
    }

    /** Разбиение главы на массив строк-стихов
     */
    private ArrayList ReadBibleBookChapterVerses(String chapterStr) throws IOException {
        ArrayList result = new ArrayList();// объявляем переменную результата
        int pointer = 0; // указатель на текущую позицию
        while (pointer < chapterStr.length()) {
            result.add(chapterStr.substring(pointer, chapterStr.indexOf("\n", pointer)));
            pointer = chapterStr.indexOf("\n", pointer)+1;
        }
        return result;
    }

    /** Чистка стиха: удаление тегов <> и текста в фигурных скобках {}
     */
    private String StripTags(String verse) {
        //if (verse.indexOf('<')<0) return verse; // тегов в строке нет
        //String result = "";
        //boolean flagRead = true;
        //for(int i=0;i<verse.length();i++) {
        //    if (verse.charAt(i) == '<') flagRead = false;
        //    else if (verse.charAt(i) == '>') flagRead = true;
        //    else if (flagRead) result = result + verse.substring(i,i+1);
        //}
        String result = verse;
        Pattern tags = Pattern.compile("[<{].*?[>}]");
        Matcher tagMatcher = tags.matcher(result);
        result = tagMatcher.replaceAll("");
        return result;
    }

    /** Чистка стиха: удаление номеров Стронга
     */
    private String DeleteStrongsN(String verse) {
        if (!isStrongNumbers) return verse; // номеров Стронга в модуле нет
        String result = "";
        verse = verse + " ";
        boolean flagRead = true;
        for(int i=0;i<verse.length()-1;i++) {
            if ((verse.charAt(i) == ' ')&&(verse.charAt(i+1) >= '0')&&(verse.charAt(i+1) <= '9')) flagRead = false;
            else if ((verse.charAt(i) < '0')||(verse.charAt(i) > '9')) flagRead = true;
            if (flagRead) result = result+verse.substring(i,i+1);
        }
        return result.trim();
    }

    /** Чистка стиха: удаление номера стиха
     */
    private String DeleteVNumber(String verse) {
        return verse.substring(verse.indexOf(' ')+1);
    }

    /** Получение количества стихов (строк) в главе
     */
    private int GetVerseNumbers(String chapter) {
        int result = 1;
        for(int i=0;i<chapter.length();i++)
            if (chapter.charAt(i) == '\n') result++;
        return result;
    }
 
    /** Завершение работы программы
     */
    private void btnExitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnExitActionPerformed
        System.exit(0);
    }//GEN-LAST:event_btnExitActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new bq2jBible().setVisible(true);
            }
        });
    }
   
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnAbout;
    private javax.swing.JButton btnExit;
    private javax.swing.JButton btnOpen;
    private javax.swing.JButton btnSave;
    private javax.swing.ButtonGroup groupChoice;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel labelChoice;
    private javax.swing.JLabel labelLocale;
    private javax.swing.JLabel labelMidletName;
    private javax.swing.JLabel labelModuleName;
    private javax.swing.JLabel labelPath;
    private javax.swing.JList lstLocale;
    private javax.swing.JPanel panelBooks;
    private javax.swing.JPanel panelMidlet;
    private javax.swing.JPanel panelModule;
    private javax.swing.JRadioButton radioChoice1;
    private javax.swing.JRadioButton radioChoice2;
    private javax.swing.JRadioButton radioChoice3;
    private javax.swing.JRadioButton radioChoice4;
    private javax.swing.JScrollPane scrollBooks;
    private javax.swing.JTextField txtMidletName;
    private javax.swing.JTextField txtModuleName;
    private javax.swing.JTextField txtPath;
    private javax.swing.JTextField txtStatus;
    // End of variables declaration//GEN-END:variables
    
}